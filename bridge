#!/usr/bin/env python3

"""
Crappy Network Interface

Very minimal Container Network Interface plugin for FreeBSD

Basic usage:
    1. ONLY reads/honors /etc/cni/net.d/10-bridge.conflist
    2. Gets request
    3. ???
    4. Returns value

Command notes:
    ADD - creates only, no modification supported
    CHECK - unimplemented
    DEL - not yet implemented
    VERSIONS - implemented

Notes:
    * IPv4 only
    * NAT, if desired, must be managed manually
    * All plugins in one! Does not delegate to plugins
    * full of non-compliant race conditions

Todo (maybe?):
    * read configuration from /etc/cni/net.d
    * plugins should be split out
    * data should be passed internally as structs, probably
    * no real error handling

Required parameters (CNI spec):
    CNI_COMMAND
    CNI_CONTAINERID
    CNI_IFNAME -- harcoded as "eth0"
    CNI_NETNS -- FreeBSD doesn"t use named network isolation domains (?)

We ignore the following parameters:
    CNI_ARGS
    CNI_PATH -- using /opt/cni/bin
"""

import ipaddress
import json
import os
import random
import re
import subprocess
import sys


### Globals

# Don"t execute ifconfig
NOOP = True

# Supported versions message
# Pretty sure this doesn"t actually support all these versions
version_json = """
{
    "cniVersion": "1.0.0",
    "supportedVersions": [
        "0.3.1", "0.4.0", "1.0.0"
    ]
}
"""

class CNIConfig:
    """
    Methods for reading CNI config values
    """

    def __init__(self, input):
        self.config = CNIConfig.__read_input(input)
        self.cni_version = CNIConfig.cni_version()

    def cni_version():
        versions = json.loads(version_json)
        return versions["cniVersion"]

    def __read_input(input):
        try:
            input_config = json.loads(input)
        except:
            return_error(5, "Invalid input JSON", "Cannot parse STDIN")

        return input_config

    def bridge(self):
        return self.config["bridge"]

    def subnet(self):
        return self.config["ipam"]["subnet"]

    def gateway(self):
        return self.config["ipam"]["gateway"]



class CNIRequest:
    """
    Interface for CNI environment variables

    Supported/required vars:
        CNI_COMMAND
        CNI_CONTAINERID
        CNI_IFNAME -- harcoded as "eth0"
        CNI_NETNS -- FreeBSD doesn"t use named network isolation domains (?)

    We ignore the following parameters:
        CNI_ARGS
        CNI_PATH -- using /opt/cni/bin
    """

    env_vars = ["CNI_COMMAND", "CNI_CONTAINERID", "CNI_IFNAME", "CNI_NETNS"]
    verbs = ["ADD", "DEL", "CHECK", "VERSION"]

    def __init__(self):
        for ev in CNIRequest.env_vars:
            if ev == "CNI_COMMAND":
                self.command = self.__verb()
            elif ev == "CNI_CONTAINERID":
                self.container_id = self.__read_var( ev)
            elif ev == "CNI_IFNAME":
                self.ifname = self.__read_var(ev)
            elif ev == "CNI_NETNS":
                self.netns = self.__read_var(ev)

    def __verb(self):
        verb = os.environ.get("CNI_COMMAND")
        if verb is None or verb not in CNIRequest.verbs:
            return_error(4, "Invalid CNI_COMMAND",
                "CNI_COMMAND must be one of " + ", ".join(CNIRequest.verbs))
        else:
            return verb

    def __read_var(self, ev):
        value = os.environ.get(ev)
        if value is None:
            return_error(4, ev + " invalid", ev + " parameter invalid")
        else:
            return value


class AddResult:
    """
    Holds structure for ADD results
    """
    def __init__(self, cni, request):
        self.cni_version = CNIConfig.cni_version()
        self.cni = cni
        self.request = request
        self.interfaces = [
                {
                    "name": "eth0",
                    "mac": gen_mac_addr(),
                    "sandbox": request.netns
                }
        ]
        self.ips = [
                {
                    "version": "4",
                    "gateway": self.cni.gateway()
                }
        ]


    def set_address(self, address):
        self.ips[0]["address"] = address

    def set_interface(self, interface):
        self.ips[0]["interface"] = interface

    def json_output(self):
        result = {
                "cniVersion": self.cni_version,
                "interfaces": self.interfaces,
                "ips": self.ips
                }
        return json.dumps(result)



class DelResult:
    """
    Holds structure for ADD results

    Not done
    """
    def __init__(self):
        self.cni_version = CNIConfig.cni_version()
        self.cni = cni
        self.request = request



def command_add(cni, request):
    """
    CNI ADD verb
    """

    result = AddResult(cni, request)
    ip, net_if = host_local_add(cni.bridge)
    result.set_address(ip)
    result.set_interface(net_if)

    print(result.json_output())


def command_del(cni, request):
    """
    CNI DEL verb
    """

    print("not yet implemented")
    exit(1)


def command_check(cni, request):
    """
    CNI CHECK verb

    added in CNI v0.4

    Should not get called if "disableCheck" is false in cni conf
    """

    print("Not implemented")
    exit(0)


def command_version():
    """
    CNI VERSION verb
    """

    print(version_json)
    exit(0)



def return_error(code, msg, details):
    """
    Return the error message as shown at
    https://github.com/containernetworking/cni/blob/main/SPEC.md#Error

    This method makes no checks on its args
    """

    return_msg = (CNIConfig.cni_version(), code, msg, details)
    """
    {
      "cniVersion": {0},
      "code": {1},
      "msg": {2},
      "details": {3}
    }
    """

    print(return_msg, file=sys.stderr)
    exit(code)


def host_local_add(bridge):
    """
    Create the interface

    tap device number hardcoded for testing, needs to be broken out
    """

    ip = get_new_ip()
    tap_number = get_new_tap()
    tap = "tap" + str(tap_number)

    create_tap(ip, tap, bridge)
    # return ip, host interface
    return ip, tap


def get_new_ip():
    """
    Hardcoded stub for now. Should check something stateful for unused IPs
    in subnet range

    Netmask added later

    Todo: check for free IPs
    """

    address = "172.16.0.12"
    return address


def get_new_tap():
    """
    Hardcoded stub for now. Should check something stateful for unused tap
    interface numbers

    Todo: check for unused tap interfaces
    """

    return 2


def create_tap(ip, tap_if, bridge):
    """
    Create the tap network device

    No error checking here
    """

    if not NOOP:
        try:
            os.system("ifconfig " + tap_if + " create")
            os.system("ifconfig " + bridge + " addm " + tap_if)
            os.system("ifconfig " + tap_if + " inet " + ip)
            os.system("ifconfig " + tap_if + " up")
        except:
            return_error(11, "Failed to create device",
                    "Failed to create network device")


def get_mac_addr(device):
    """
    Parse device MAC addresses from ifconfig output
    """
    if not NOOP:
        try:
            ifconfig = subprocess.run(["ifconfig", device],
                    stdout=subprocess.PIPE)
            ifout = ifconfig.stdout.decode("UTF-8")
            print(ifout)

            em = re.compile(r"ether\s+(..:..:..:..:..:..)")
            m = em.search(ifout)
            print(m.group(1))
        except:
            return_error(11, "Failed status check",
                    "Failed to get network status")


def gen_mac_addr():
    """
    Generate random MAC address
    """

    hexes = [ 0x01, 0x02, 0x03,
            random.randint(0x00, 0xff),
            random.randint(0x00, 0xff),
            random.randint(0x00, 0xff) ]
    return ":".join(f"{n:02X}" for n in hexes)


def fix_netmask(octet_mask):
    """
    Convert xxx.xxx.xxx.xxx mask to /xx
    ipaddress module only return octet format
    """

    nm_octets = nm_octet.split(".")
    cidr = sum([bin(int(octet)).count("1") for octet in nm_octets.split(".")])
    return cidr



def main():
    request = CNIRequest()

    input_json = "".join(sys.stdin.readlines())
    # TODO validate passed config against /etc/cni/net.d conf(s)
    plugin = CNIConfig(input_json)


    if request.command == "ADD":
        command_add(plugin, request)
    elif request.command == "DEL":
        command_del(plugin, request)
    elif request.command == "CHECK":
        command_check(plugin, request)
    elif request.command == "VERSION":
        command_version()



if __name__ == "__main__":
    main()
